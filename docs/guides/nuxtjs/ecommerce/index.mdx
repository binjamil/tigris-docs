---
title: "Building an E-Commerce Store with Nuxt and Tigris Full-text Search"
---

import tigrisConfig from "@site/tigris.config.js";

import TerminalWindow from "@site/src/components/TerminalWindow/index";
import CodeBlock from "@theme/CodeBlock";
import envDevOutput from "!!raw-loader!./_envFileInput";
import {
  HomepageCard as Card,
  HomepageSection as Section,
} from "../../../../src/components/HomepageComponents";
import Installation from "@site/docs/includes/_install_cloud_login.mdx";

# Building an E-Commerce Store with Nuxt and Tigris Full-text Search

Search is a fundamental part of an application especially when we build retail and e-commerce applications. Search
provides your customers a great shopping experience. This tutorial will demonstrate how [Tigris](https://docs.tigrisdata.com/)
makes it super easy to add real-time and relevance-based full-text search to your application. Tigris has an embedded search engine
which automatically makes all your data searchable.

The guide will be focusing mainly on integrating full-text search capabilities using Tigris and Nuxt.js and may skip
over few things like styling etc. which will be pre-generated in the template used for this tutorial.

[Here is a link](https://nuxt-ecommerce-netlify.netlify.app/) to working example of this e-commerce store
that you will build. The source code is available on [GitHub repo](https://github.com/tigrisdata/tigris-netlify-ecommerce) if you feel
like exploring on your own, else follow along the tutorial.

## Prerequisites

<Installation />

## Getting Started

The first step is to clone the repository that contains the starting source code.

```mdx-code-block
<TerminalWindow>
<CodeBlock language="shell">git clone https://github.com/tigrisdata/tigris-netlify-ecommerce</CodeBlock>
</TerminalWindow>
```

`cd` into the project directory

```shell
cd tigris-netlify-ecommerce
```

The layout of this project is like below.

```text
tigris-netlify-ecommerce
├── package.json
└── pages
    ├── all.vue
    ├── cart.vue
    ├── index.vue
    ├── women.vue
    └── men.vue
└── layouts
    ├── default.vue
└── static
    ├── storedata.json
└── functions
    ├── read-all-products.ts
    ├── create-payment-intent.ts
    └── handle-payment-succeeded.ts
|── lib
    └── tigris.ts
├── db
│   └── models
|       └── products.ts
|── scripts
    └── setup.ts
└── store
    └── index.js
```

- `db/models/products.ts` - Defines the product collection schema.
- `scripts/setup.ts` - Initializes the database and creates collections.
- `lib/tigris` - Initializes and exports the Tigris client for use in other modules.
- `store/` - The Vuex store folder.
- `package.json` - Node project configuration file.
- `pages/` - Holds all Vue component files (template, logic, and styling).
- `functions/` - Contains all the serverless function definitions (API endpoints) for the app.

## Create a Tigris Project

To connect your e-commerce store app with a Tigris database, you need to create a Tigris project.
To create one, go to your <a href={tigrisConfig.consoleUrl}>Tigris Cloud Console</a>, click **Create a new project**, name it `catalog`, and click **Create**.

![The create a project dialog within the Tigris console web application](/img/screenshots/create-new-project-dialog.jpg)

Select **Go to Project** in the next dialog.

### Configure environment variables

After creating a project, Tigris generates an app key with necessary credentials automatically.
Go to **Application Keys**, click the eye icon for the listed key, and a dialog will appear with values to configure your local app using environment variables.

- `TIGRIS_URI` - the URL for your Tigris platform setup. If you're using Tigris Cloud, it should be "api.preview.tigrisdata.cloud."
- `TIGRIS_PROJECT` - name of your project in Tigris, not to be confused with your application key name.
- `TIGRIS_CLIENT_ID` - a client ID for your application key.
- `TIGRIS_CLIENT_SECRET` - a secret for your application key.
- `TIGRIS_DB_BRANCH` - The database branch name. We recommend using the **main** branch for a production environment, while other branches can be used for development.

Update the `.env.development` file with values for `TIGRIS_URI`, `TIGRIS_PROJECT`, `TIGRIS_CLIENT_ID`, and `TIGRIS_CLIENT_SECRET` from the Tigris web console.
Set the `TIGRIS_DB_BRANCH` to specify a branch for the Tigris database.

```dotenv title=.env.development
TIGRIS_URI=api.preview.tigrisdata.cloud
TIGRIS_PROJECT=catalog
TIGRIS_CLIENT_ID=ftSxxx
TIGRIS_CLIENT_SECRET=DOxxx
TIGRIS_DB_BRANCH=develop
```

After this, run the `setup` script and that will automatically create your database collection and load
the product data is defined present [here](https://github.com/tigrisdata/tigris-netlify-ecommerce/blob/ecommerce-search-scaffold/static/storedata.json).

```mdx-code-block
<TerminalWindow>
<CodeBlock language="shell">npm run setup</CodeBlock>
</TerminalWindow>
```

```text
> ecommerce-netlify@1.0.0 setup
> npx ts-node scripts/setup.ts

info - Using Tigris at: api.preview.tigrisdata.cloud:443
info - Using database branch: 'main'
event - Creating collection: 'products' in project: 'catalog'
Inserted 30 documents
Setup complete ...
```

## Add full-text search capabilities

To add full-text search to our application, we only need to perform three steps:

- Serverless functions to call Tigris search
- Async action in vuex store to call Tigris search serverless function
- Search vue to have search text in the UI

### Step:1 Serverless functions to call Tigris Search

Let's write a serverless function to add search functionality to the e-commerce store. This
serverless function will be used by the vuex store to power search functionality for the application.

#### ⌲ Add the following code inside `functions/search-products.ts`.

```ts title=functions/search-products.ts
import { Handler } from "@netlify/functions";
import { Product } from "../db/models/product";
import tigrisDb from "../lib/tigris";

const handler: Handler = async (event, context) => {
  const searchReq = JSON.parse(event.body);

  if (!searchReq.q) {
    console.log("search keyword is missing");
    return {
      statusCode: 400,
      body: JSON.stringify({
        status: "search keyword is missing",
      }),
    };
  }

  try {
    const products = tigrisDb.getCollection<Product>(Product);

    const searchResult = await products.search(searchReq);

    const productHits = [];
    for await (const res of searchResult) {
      res.hits.forEach((hit) => productHits.push(hit.document));
    }
    return {
      statusCode: 200,
      body: JSON.stringify(productHits),
    };
  } catch (err) {
    console.log(err);
    return {
      statusCode: 500,
      body: JSON.stringify({
        status: err,
      }),
    };
  }
};

export { handler };
```

The main thing to note in the above serverless function is that we are simply calling `search` on the product collection.

### Step2: Integrate Search Serverless functions in vuex store

The next step is to integrate the serverless function that we have just added above in the vuex store.
Here we will be adding an async action `searchProducts`. As you can notice in the following code that
this async action is passing the keyword to the serverless function that we have added above. This keyword
is the text that user wants to search in the application. We will see in Step3 on how the vue is passing the
text to this async action.

#### ⌲ Add the following code inside actions `export const actions = {...}` in `store/index.ts`

```ts title=searchProducts
async searchProducts({ commit }, keyword) {
  try {
    const response = await axios.post(
      "/.netlify/functions/search-products",
      {
        q: keyword,
      },
      {
        headers: {
          "Content-Type": "application/json"
        }
      }
    );
    if (response.data) {
      commit("searchProducts", response.data);
    }
  } catch (e) {
    console.log("error", e);
  }
}
```

The next step is to update the mutations based on the actions that we have added. Add the `searchProducts` in the
`export const mutations = {...}` by adding the following code.

```ts title=searchProducts
searchProducts: (state, payload) => {
  state.searchdata = payload;
};
```

> Note: Add a new variable "searchdata" in the state so that mutations can update it.

Add a `searchResult` inside getters `export const getters = {...}` to access search results

```ts title=searchResult
searchResult: (state) => state.searchdata;
```

### Step3: Search vue to have search text in the UI

Create a vue file and add the following code to it.

```js title=pages/search.vue
<template>
    <div>
        <div class="searchHeader">
            <input type="text" v-model="keyword" placeholder="Search Keyword" />
            <button
                class="searchBtn"
                @click="search"
                :disabled="loading || !keyword"
                >{{(!loading) ? 'Search Products' : 'Loading...'}}</button>
        </div>

        <p class="noResults" v-if="usingSearch && !loading && searchResult.length<1">No results found..</p>

        <app-store-grid :data="(usingSearch) ? searchResult : storedata" />
    </div>
</template>
<script>
import AppStoreGrid from "~/components/AppStoreGrid.vue"
import { mapGetters, mapState } from 'vuex';
export default {
    components: {
        AppStoreGrid
    },
    computed: {
        ...mapGetters(["searchResult"]),
        ...mapState(["storedata"])
    },
    data() {
        return {
            keyword: "",
            error: "",
            loading: false,
            usingSearch: false,
        };
    },
    methods: {
        search() {
            this.loading = true;
            this.usingSearch = true;
            this.$store.dispatch("searchProducts", this.keyword).
            then(() => {
                this.loading = false;
            })
        }
    }
};
</script>

<style lang="scss" scoped>
.noResults {
    text-align: center;
}
.searchBtn {
    width: 180px;
}
.searchHeader {
    display: flex;
    justify-content: center;
    gap: 10px;
    margin-bottom: 40px;
}
</style>
```

Now, add this search.vue to the AppNav.vue component.

```js
<li>
  <nuxt-link to="/search">Search</nuxt-link>
</li>
```

At this point, you have successfully integrated Search in your application. You can also check out the full code [here](https://github.com/tigrisdata/tigris-netlify-ecommerce).

## Run the app

Let's reap the rewards. Run `netlify dev` using netlify CLI in terminal.

You should see following output:

```mdx-code-block
<TerminalWindow>
<CodeBlock language="shell">netlify dev</CodeBlock>
</TerminalWindow>
```

Output

```text
◈ Netlify Dev ◈
◈ Ignored netlify.toml file env var: TIGRIS_URI (defined in .env file)
◈ Injected .env file env var: TIGRIS_URI
◈ Ignored general context env var: LANG (defined in process)
◈ Injected .env file env var: TIGRIS_CLIENT_ID
◈ Injected .env file env var: TIGRIS_CLIENT_SECRET
◈ Loaded function create-payment-intent.
◈ Loaded function handle-payment-succeeded.
◈ Loaded function read-all-products.
◈ Functions server is listening on 50405
◈ Setting up local development server

────────────────────────────────────────────────────────────────
  Netlify Build
────────────────────────────────────────────────────────────────

❯ Version
  @netlify/build 27.20.1

❯ Flags
  {}

❯ Current directory
  /Users/himank/tigris-netlify-ecommerce

❯ Config file
  /Users/himank/tigris-netlify-ecommerce/netlify.toml

❯ Context
  dev

────────────────────────────────────────────────────────────────
  1. Run command for local development
────────────────────────────────────────────────────────────────

◈ Starting Netlify Dev with Nuxt 2
yarn run v1.22.19
warning ../package.json: No license field
$ nuxt dev
ℹ Listening on: http://localhost:3000/
ℹ Preparing project for development
ℹ Initial build may take a while
✔ Builder initialized
✔ Waiting for framework port 3000. This can be configured using the 'targetPort' property in the netlify.toml

(dev.command completed in 2s)
✔ Nuxt files generated

   ┌─────────────────────────────────────────────────┐
   │                                                 │
   │   ◈ Server now ready on http://localhost:8888   │
   │                                                 │
   └─────────────────────────────────────────────────┘
```

Voila! there you have it. E-commerce store is accessible on [http://localhost:8888](http://localhost:8888)
on your browser, go ahead and play around.

## Summary

In this tutorial, we have added search functionality to a Nuxt app using Tigris search. As we can see it is
super easy, and everything happened in the code. You can also check out your database and collection in
Tigris <a href={tigrisConfig.consoleUrl}>console</a>. Now, it's time to [tweet your success][tweet-intent] :smile:

Stay, tuned as we publish more tutorials and reach out to the team to learn what we are building next.

Happy learning!

<!-- MARKDOWN LINKS -->

[nuxtjs-url]: https://nuxtjs.org/
[tigris-netlify-ecommerce]: https://github.com/tigrisdata/tigris-netlify-ecommerce
[tweet-intent]: https://twitter.com/intent/tweet?url=https%3A%2F%2Ftigrisdata.com%2Fnextjs%2F&text=I%20learned%20how%20easy%20it%20is%20to%20build%20%23data%20rich%20applications%20using%20@nextjs%20and%20@TigrisData
