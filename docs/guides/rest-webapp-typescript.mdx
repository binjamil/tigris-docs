# TypeScript RESTful Web App

In this guide we will build a RESTful web application that demonstrates the
following features of Tigris:

- Flexible Document Model
- Full-text Search
- Automatic Indexing
- Transactions
- Simple APIs

This tutorial would provide you with a starting point towards building a
feature rich web application.

:::info

The application uses the [Express](https://expressjs.com/) framework.

:::

Now let's get started with Tigris.

## Getting Started

Clone the application code repository:

```shell
git clone https://github.com/tigrisdata/tigris-starter-ts.git
```

And navigate to the directory created

```shell
cd tigris-starter-ts
```

import StartupLocally from "@site/docs/includes/_startup_tigris_locally.mdx";

<StartupLocally />

### Create a Tigris Project

Create a Tigris project for your TypeScript RESTful web application:

```shell
tigris create project tigris_starter_ts "TypeScript RESTful App"
```

### Create a Project Application Key

After the project is created, generate an application key for it:

```shell
tigris create app_key "my app key" --project=tigris_starter_ts
```

The result will be as follows:

```
{
  "id": "dummy-id",
  "name": "my app key",
  "secret": "dummy-secret",
  "created_at": 1668493288000,
  "created_by": "google-oauth2|107496644751065904534",
  "project": "tigris_starter_ts"
}
```

The following table illustrates the correlation between the JSON property ID and the environment variable:

| API KEY | Environment variable   |
| ------- | ---------------------- |
| id      | `TIGRIS_CLIENT_ID`     |
| secret  | `TIGRIS_CLIENT_SECRET` |
| name    | `TIGRIS_PROJECT`       |

You must add `TIGRIS_URI` and `TIGRIS_DB_BRANCH` to your environment file. Use `api.preview.tigrisdata.cloud` for TIGRIS_URI and `TIGRIS_DB_BRANCH`, use **main** for a production app and **develop** or another branch name for development.
Create a `.env` file in the root directory of your project and add the credentials to it. Your `.env` file will look as follows:

```dotenv title=.env
TIGRIS_URI=api.preview.tigrisdata.cloud
TIGRIS_PROJECT=tigris_starter_ts
TIGRIS_CLIENT_ID=ftSxxx
TIGRIS_CLIENT_SECRET=DOxxx
TIGRIS_DB_BRANCH=main
```

## Starting the application

### Build the project

The next step is to build project:

```shell
npm run build
```

### Run the application

```shell
npm run dev
```

## Using the application

### CRUD operations

Tigris allows you to quickly add data and easily retrieve or edit that data
through simple and intuitive APIs. Continue using your preferred programming
language, there is no new database query language to learn.

Take a look at the source files inside
[src/controllers](https://github.com/tigrisdata/tigris-starter-ts/tree/main/src/controllers)
to see how Tigris CRUD APIs are used.

Let's create user and product records, and then read them back.

#### Insert users

Run following commands to create two user records:

```shell
curl localhost:8080/users/create \
    -X POST \
    -H 'Content-Type: application/json' \
    -d '{
          "name":"John",
          "balance":100
        }'
```

```shell
curl localhost:8080/users/create \
    -X POST \
    -H 'Content-Type: application/json' \
    -d '{
          "name":"Jane",
          "balance":200
        }'
```

#### Insert products

Run the following commands to insert some product records:

```shell
curl localhost:8080/products/create \
    -X POST \
    -H 'Content-Type: application/json' \
    -d '{
          "name":"Avocado",
          "price":10,
          "quantity":5
        }'
```

```shell
curl localhost:8080/products/create \
    -X POST \
    -H 'Content-Type: application/json' \
    -d '{
          "name":"Avocado Oil",
          "price":80,
          "quantity":15
        }'
```

```shell
curl localhost:8080/products/create \
    -X POST \
    -H 'Content-Type: application/json' \
    -d '{
          "name":"Gold",
          "price":3000,
          "quantity":1
        }'
```

#### Read the records

Now go ahead and confirm that the data has been persisted:

```shell
curl http://localhost:8080/users
```

```shell
curl http://localhost:8080/products
```

### Full-text search

Tigris comes with an integrated search engine that eliminates the need to
run a separate search platform and synchronize data.

Let's search for users named "Jane":

```shell
curl http://localhost:8080/users/search \
    -X POST \
    -H 'Content-Type: application/json' \
    -d '{"query": "jane"}'
```

Or, search for products named "avocado" and price less than 50:

```shell
curl localhost:8080/products/search \
    -X POST \
    -H 'Content-Type: application/json' \
    -d '{
        "query": "avocado",
        "searchFields": ["name"],
        "filter": {"price": {"$lt": 50}}
      }'
```

## Extending the application

One of the main features of Tigris is the ability to perform ACID
transactions. Now let's set up a HTTP handler that will perform the insert
and update operations in a transaction ensuring that the collections are
consistently updated.

Open the project in your favorite IDE and add the following to
`src/controllers/order-controller.ts`

#### Additional imports

```typescript title="order-controller.ts"
import { User } from "../models/user";
import { Product } from "../models/product";
```

#### New HTTP handler

```typescript title="order-controller.ts"
public createOrder = async (req: Request, res: Response) => {
    // get user
    const user: User | undefined = await this.db
      .getCollection<User>(User)
      .findOne({
        filter: {
          userId: req.params.userId,
        },
      });
    if (user === undefined) {
      res.status(404).json({ error: "User not found" });
      return;
    }

    // get product
    const product: Product | undefined = await this.db
      .getCollection<Product>(Product)
      .findOne({
        filter: {
          productId: req.params.productId,
        },
      });
    if (product === undefined) {
      res.status(404).json({ error: "Product not found" });
      return;
    }

    // read quantity for order
    const qty = Number.parseInt(req.params.quantity);

    // check quantity available
    if (qty > product.quantity) {
      res.status(412).json({ error: "Insufficient product quantity" });
      return;
    }
    const orderTotal: number = qty * product.price;

    // check balance available
    if (user.balance < orderTotal) {
      res.status(412).json({ error: "Insufficient user balance" });
      return;
    }

    // deduct balance
    await this.db.getCollection<User>(User).updateOne({
      filter: {
        userId: user.userId,
      },
      fields: {
        balance: user.balance - orderTotal,
      },
    });
    console.log("deducted user balance");

    // deduct product quantity
    await this.db.getCollection<Product>(Product).updateOne({
      filter: {
        productId: product.productId,
      },
      fields: {
        quantity: product.quantity - qty,
      },
    });
    // create order
    const order: Order = {
      orderTotal: orderTotal,
      userId: Number.parseInt(user.userId),
      productItems: [
        {
          productId: product.productId,
          quantity: qty,
          name: product.name,
          price: product.price,
        },
      ],
    };

    await this.orders.insertOne(order);
    console.log("order created");

    res.status(200).json({ status: "Order placed successfully" });
  };
```

#### Configure HTTP route

Add the following new route to the `OrderController.setupRoutes` function:

```typescript title="order-controller.ts"
this.router.post(`${this.path}/:userId/:productId/:quantity`, this.createOrder);
```

Now that we have set up the new HTTP route, let's use it to create a new
order record.

#### Insert an order

Replace `{user-id}`, and `{product-id}` below with IDs of the records you
see when running the commands in the [Read the records](#read-the-records)
section:

```shell
curl -X 'POST' 'http://localhost:8080/orders/{user-id}/{product-id}/4'
```

#### Read all order records

Now go ahead and confirm that the order record has been persisted:

```shell
curl http://localhost:8080/orders
```

## Understanding what just happened

When you executed the `create project` command, a database named **tigris_starter_ts** was created. Upon running the `create app_key` command, your application's credentials were generated in the **tigris_starter_ts** database.
Launching the application triggered the instant creation of the collections, users, products, and orders, through code located in `App.initializeTigris`. All of this was done
instantaneously in true serverless fashion.

The model definitions for these collections are located
inside [src/db/models/](https://github.com/tigrisdata/tigris-starter-ts/tree/main/src/db/models) folder.

You also leveraged the search features through code
without having to setup any complicated infrastructure.
