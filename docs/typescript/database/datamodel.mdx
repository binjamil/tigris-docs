# Data Modeling

Tigris enables the data models to be declared as part of the
application code. These data models are then converted to appropriate
objects, such as collections, on the backend.

## Declaring Models

There are two basic constructs for TypeScript Tigris modeling.

1. Data containers - interface that holds the data model
2. Schema of Data containers - TigrisSchema definition of these data containers.

```ts
// data container
interface Catalog extends TigrisCollectionType {
  id?: string;
  name: string;
  price: number;
  brand: string;
  labels: string;
  popularity: number;
  entryDate: Date;
  enabled: boolean;
}

// schema definition
const catalogSchema: TigrisSchema<Catalog> = {
  id: {
    type: TigrisDataTypes.INT64,
    primary_key: {
      order: 1,
      autoGenerate: true,
    },
  },
  name: {
    type: TigrisDataTypes.STRING,
  },
  price: {
    type: TigrisDataTypes.NUMBER,
  },
  brand: {
    type: TigrisDataTypes.STRING,
  },
  labels: {
    type: TigrisDataTypes.STRING,
  },
  popularity: {
    type: TigrisDataTypes.INT32,
  },
  entryDate: {
    type: TigrisDataTypes.DATE_TIME,
  },
  enabled: {
    type: TigrisDataTypes.BOOLEAN,
  },
};
```

:::info

- You must keep the data container and schema definition in sync.
- The primary key field is marked as `autoGenerate=true` which is why it
  is defined as an optional field.

:::

### Create the Collection

Creates the collection with the model and any new operation will see the changes.

```typescript
const catalog = await db.createOrUpdateCollection<Catalog>(
  "catalog",
  catalogSchema
);
```

## Embedded Data Model

Tigris offers rich documents that enable embedding related data in a single
document. Embedded models allow applications to complete database operations
with fewer queries or updates, thus reducing query activity and increasing
efficiency.

Below is an example of embedded data model. We first define the `ProductItem`
type and then embed it inside the `Order` type.

```typescript
// data containers
export interface ProductItem {
  productId: string;
  quantity: number;
}
export interface Order extends TigrisCollectionType {
  orderId?: string;
  userId: string;
  productItems: ProductItem[];
  orderTotal: number;
}

// schema definitions
const productItemSchema: TigrisSchema<ProductItem> = {
  productId: {
    type: TigrisDataTypes.INT64,
  },
  quantity: {
    type: TigrisDataTypes.INT64,
  },
};
export const orderSchema: TigrisSchema<Order> = {
  orderId: {
    type: TigrisDataTypes.INT64,
    primary_key: {
      order: 1,
      autoGenerate: true,
    },
  },
  userId: {
    type: TigrisDataTypes.INT64,
  },
  orderTotal: {
    type: TigrisDataTypes.NUMBER,
  },
  productItems: {
    type: TigrisDataTypes.ARRAY,
    items: {
      type: productItemSchema,
    },
  },
};
```

## Primary Key

A primary key uniquely identifies a document in the collection and enforces
the unique constraint. In the absence of a user-defined primary key, it is
auto-generated.

### Defining a Primary Key

The example above demonstrates how primary key is defined. The `order`
attribute in `primaryKey` represents the order of the field in the primary key.
While `autoGenerate: true` represents that the values for this field will be
automatically generated by the Tigris server.

### Composite Primary Key

Composite primary keys are also supported but in case of composite keys
order of the fields is important. The example below demonstrates
how the order of the fields are defined in case of a composite primary key

```typescript
// data container
interface Catalog extends TigrisCollectionType {
  id?: number;
  name: string;
}

// schema definition
const catalogSchema: TigrisSchema<Catalog> = {
  id: {
    type: TigrisDataTypes.INT64,
    primary_key: {
      order: 1,
      autoGenerate: true,
    },
  },
  name: {
    type: TigrisDataTypes.STRING,
    primary_key: {
      order: 2,
    },
  },
};
```

### Auto-generated Primary Key

If no primary key is specified in the model, Tigris automatically adds a
special `id` field of type `string` (UUID) as the primary key.

At later point if you want to read this field to your data container you can
add this field into your data container.

```typescript
export interface Catalog extends TigrisCollectionType {
  id: string;
  productId: number;
  name: string;
  price: number;
}
```

Note: you do not need to explicitly mention this `id: string` field to your
schema definition. It is available implicitly (as long as you don't have
primary key defined).
