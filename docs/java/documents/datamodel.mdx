# Data Modeling

Tigris enables the data models to be declared as part of the
application code. These data models are then converted to appropriate
objects, such as collections, on the backend.

# Declaring Models

Models are regular Java model (POJO) comprised of primitive and wrapper Java types, or custom types.

```java
package com.tigrisdata.db.client.collection;

import com.tigrisdata.db.annotation.TigrisField;
import com.tigrisdata.db.annotation.TigrisPrimaryKey;
import com.tigrisdata.db.type.TigrisDocumentCollectionType;
import java.util.Objects;

@TigrisCollection(value = "catalog")
public class Catalog implements TigrisDocumentCollectionType {
  @TigrisField(description = "A unique identifier for the catalog item")
  @TigrisPrimaryKey(order = 1, autoGenerate = true)
  private int id;

  @TigrisField(description = "Product name")
  private String name;

  @TigrisField(description = "Product price")
  private double price;

  @TigrisField(description = "Brand name")
  private String brand;

  @TigrisField(description = "Categorized item label")
  private String labels;

  @TigrisField(description = "Product's popularity rating")
  private int popularity;

  public Catalog() {}

  public Catalog(String name, double price, String brand, String labels, int popularity) {
    this.name = name;
    this.price = price;
    this.brand = brand;
    this.labels = labels;
    this.popularity = popularity;
  }

  public int getId() {
    return id;
  }

  public void setId(int id) {
    this.id = id;
  }

  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public double getPrice() {
    return price;
  }

  public void setPrice(double price) {
    this.price = price;
  }

  public String getBrand() {
    return brand;
  }

  public void setBrand(String brand) {
    this.brand = brand;
  }

  public String getLabels() {
    return labels;
  }

  public void setLabels(String labels) {
    this.labels = labels;
  }

  public int getPopularity() {
    return popularity;
  }

  public void setPopularity(int popularity) {
    this.popularity = popularity;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Catalog catalog = (Catalog) o;
    return id == catalog.id && Double.compare(catalog.price, price) == 0
        && popularity == catalog.popularity && Objects.equals(name, catalog.name)
        && Objects.equals(brand, catalog.brand) && Objects.equals(labels,
        catalog.labels);
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, name, price, brand, labels, popularity);
  }
}
```

This declaration will create a collection named `catalog`.

## Collection Names

The name of the collection is derived from the Java class name. The class name
name is pluralized to snake_cases as collection name. For example, the
Java class name `Catalog` is converted to `catalogs` as the collection name. While
the Java class name `ProductDetail` is converted to `product_details` as the
collection name.

In the majority of the cases you will not need to customize the collection name,
but if you do, you can customize the collection name by using the
`@TigrisCollection` annotation. For example, the code sample below creates a
collection named `product_catalog`.

```java
@TigrisCollection("product_catalog")
public class Catalog implements TigrisDocumentCollectionType {
    //...
}
```

## Field Names

The field names in the Java class definition are also used as the field names
in the collection's schema. There is no conversion performed by default.

You can optionally add description to your fields by using the annotation
`@TigrisField` as below

```java
public class Catalog implements TigrisDocumentCollectionType {

    @TigrisField(description = "Name of the product")
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        User user = (User) o;
        return Objects.equals(name, user.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name);
    }
}
```

# Embedded Data Model

Tigris offers rich documents that enable embedding related data in a single
document. Embedded models allow applications to complete database operations
with fewer queries or updates, thus reducing query activity and increasing
efficiency.

Below is an example of embedded data model. We first define the `Product`
type and then embed it inside the `Order` type.

```java
public class Product implements TigrisDocumentCollectionType {

    @TigrisField(description = "A unique identifier for the product")
    @TigrisPrimaryKey(order = 1, autoGenerate = true)
    private int id;

    @TigrisField(description = "Name of the product")
    private String name;

    @TigrisField(description = "Number of products available in the store")
    private int quantity;

    @TigrisField(description = "Price of the product")
    private double price;

    public Product() {}

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public int getQuantity() {
        return quantity;
    }

    public double getPrice() {
        return price;
    }

    public void setId(int id) {
        this.id = id;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setQuantity(int quantity) {
        this.quantity = quantity;
    }

    public void setPrice(double price) {
        this.price = price;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Product product = (Product) o;
        return id == product.id
                && quantity == product.quantity
                && Double.compare(product.price, price) == 0
                && Objects.equals(name, product.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, name, quantity, price);
    }
}

public class Order implements TigrisDocumentCollectionType {

    @TigrisPrimaryKey(order = 1, autoGenerate = true)
    private long id;
    private long userId;
    private Product[] products;

    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    public long getUserId() {
        return userId;
    }

    public void setUserId(long userId) {
        this.userId = userId;
    }

    public Product[] getProducts() {
        return products;
    }

    public void setProducts(Product[] products) {
        this.products = products;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Order2 order2 = (Order2) o;
        return id == order2.id && userId == order2.userId && Arrays.equals(products, order2.products);
    }

    @Override
    public int hashCode() {
        int result = Objects.hash(id, userId);
        result = 31 * result + Arrays.hashCode(products);
        return result;
    }
}
```

# Primary Key

A primary key uniquely identifies a document in the collection and enforces
the unique constraint. In the absence of a user-defined primary key, it is
auto-generated.

## Defining a Primary Key

The example below demonstrates how primary key is defined. The
number in `@TigrisPrimaryKey(order = 1)` represents the order of the field
in the primary key. While `autoGenerate = true` represents that the values for
this field will be automatically generated by Tigris.

```java
public class User implements TigrisDocumentCollectionType {
    @TigrisPrimaryKey(order = 1, autoGenerate = true)
    private int id;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        User user = (User) o;
        return id == user.id;
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
}
```

## Composite Primary Key

Composite primary keys are also supported but in case of composite keys
order of the fields is important. The example below demonstrates
how the order of the fields are defined in case of a composite primary key

```java
public class User implements TigrisDocumentCollectionType {
    @TigrisPrimaryKey(order = 1, autoGenerate = true)
    private int id;

    @TigrisPrimaryKey(order = 2)
    private String email;

    private int age;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        User user = (User) o;
        return id == user.id && age == user.age && Objects.equals(email, user.email);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, email, age);
    }
}
```

## Auto-generated Primary Key

If no primary key is specified in the model, Tigris automatically adds a
special `_id` field of type `UUID` as the primary key.

You can bind this auto-generated field to your Java model by adding a
field with name `_id` and type `java.util.UUID` as shown below.

```java

public class Order implements TigrisDocumentCollectionType {
  private UUID _id; // <-- this
  private long buyerId;
  private long sellerId;
  private double tradePrice;

  public UUID get_id() {
    return _id;
  }

  public void set_id(UUID _id) {
    this._id = _id;
  }

  public long getBuyerId() {
    return buyerId;
  }

  public void setBuyerId(long buyerId) {
    this.buyerId = buyerId;
  }

  public long getSellerId() {
    return sellerId;
  }

  public void setSellerId(long sellerId) {
    this.sellerId = sellerId;
  }

  public double getTradePrice() {
    return tradePrice;
  }

  public void setTradePrice(double tradePrice) {
    this.tradePrice = tradePrice;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    Order order = (Order) o;
    return buyerId == order.buyerId
        && sellerId == order.sellerId
        && Double.compare(order.tradePrice, tradePrice) == 0;
  }

  @Override
  public int hashCode() {
    return Objects.hash(buyerId, sellerId, tradePrice);
  }
}
```

Alternatively, if you want to use a different field name in your Java model for
this auto-generated primary key, this is also possible. In the following example
the field named `orderId` will be mapped to auto generated field `_id`.

```java
public class OrderCustomized implements TigrisDocumentCollectionType {
  private long buyerId;
  private long sellerId;
  private double tradePrice;

  @TigrisField(autoGeneratedFieldMapping = AutoGeneratedFields._ID) // <-- this
  private UUID orderId;

  public UUID getOrderId() {
    return orderId;
  }

  public void setOrderId(UUID orderId) {
    this.orderId = orderId;
  }

  public long getBuyerId() {
    return buyerId;
  }

  public void setBuyerId(long buyerId) {
    this.buyerId = buyerId;
  }

  public long getSellerId() {
    return sellerId;
  }

  public void setSellerId(long sellerId) {
    this.sellerId = sellerId;
  }

  public double getTradePrice() {
    return tradePrice;
  }

  public void setTradePrice(double tradePrice) {
    this.tradePrice = tradePrice;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    OrderCustomized that = (OrderCustomized) o;
    return buyerId == that.buyerId
        && sellerId == that.sellerId
        && Double.compare(that.tradePrice, tradePrice) == 0
        && Objects.equals(orderId, that.orderId);
  }

  @Override
  public int hashCode() {
    return Objects.hash(buyerId, sellerId, tradePrice, orderId);
  }
}
```
